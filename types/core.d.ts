/// <reference path="./@mobisys-internal/cordova-plugin-inappbrowser.d.ts" />
/// <reference path="./@mobisys-internal/cordova-plugin-barcode-scanner.d.ts" />
/// <reference path="./dexie.d.ts" />
// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../dexie
//   core/interfaces.d.ts

declare module 'core' {
    import type { Api } from 'core/interfaces/api';
    /**
      * Initialize core API.
      * You will get an API instance as the result of the returned Promise.
      *
      * @function
      * @return {Promise.<module:core/interfaces/api#Api}
      */
    function init(): Promise<Api>;
    export default init;
}

declare module 'core/interfaces/api' {
    import { IExternalCommunication } from 'core/interfaces/communication';
    import DatabaseModule from 'core/interfaces/database';
    import Debugging from 'core/interfaces/debugging';
    import ErrorModule from 'core/interfaces/error';
    import { IExternalFilesystem } from 'core/interfaces/filesystem';
    import IGeoLocation from 'core/interfaces/geolocation';
    import I18n from 'core/interfaces/i18n';
    import Interop from 'core/interfaces/interop';
    import Logger from 'core/interfaces/logger';
    import { IMessagingV2 } from 'core/interfaces/messaging';
    import INFC from 'core/interfaces/nfc';
    import Packages from 'core/interfaces/packages';
    import Plugins from 'core/interfaces/plugins';
    import Session from 'core/interfaces/session';
    import Sound from 'core/interfaces/sound';
    import { ISettings } from 'core/interfaces/settings';
    import Util from 'core/interfaces/util';
    export interface Api {
        communication: IExternalCommunication;
        database: DatabaseModule;
        debugging: Debugging;
        error: ErrorModule;
        filesystem: IExternalFilesystem;
        geolocation: IGeoLocation;
        i18n: I18n;
        interop: Interop;
        logger: Logger;
        messaging: IMessagingV2;
        nfc: INFC;
        packages: Packages;
        plugins: Plugins;
        session: Session;
        settings: ISettings;
        sound: Sound;
        util: Util;
        [modName: string]: any;
    }
    export interface ApiProvider {
        /**
          * Initialize core API.
          * You will get an API instance as the result of the returned Promise.
          */
        init(): Promise<Api>;
    }
}

declare module 'core/interfaces/communication' {
    import type { SessionType } from 'core/session/session-types';
    /**
        * Legacy MSB 5 Response
        * This could be the real response text or a parsed object from SAP
        * we don't know for sure the final structure of this object
        */
    export type LegacyResponse = string | object;
    /**
        * Key Value pairs which will be transformed to queue parameters.
        */
    export type HttpParams = Record<string, string>;
    /**
        * Supported HTTP Method
        */
    export type HTTPMethod = 'delete' | 'get' | 'post' | 'put' | 'head';
    /**
        * Header collection (string key - string value pair)
        */
    export type HTTPHeaders = Record<string, string>;
    /**
        * MSB 5 Generic Response Object
        */
    export type GenericResponse = {
            body: string;
            headers: HTTPHeaders;
            code: number;
            error?: string;
    };
    /**
        * LEGACY SPECIAL File Transfer functions
        */
    export interface ILegacyFileTransfer {
            /**
                * Download a binary file from SAP.
                */
            getBinary(resourceUrl: string, targetPath?: string, sessionType?: SessionType, timeout?: number): Promise<string>;
            /**
                * Upload a binary file to SAP.
                */
            postBinary(filePath: string, sessionType?: SessionType, timeout?: number): Promise<GenericResponse>;
            /**
                * Upload the logfile to server.
                */
            uploadLogfile(filePath: string, timeout?: number): Promise<void>;
    }
    /**
        * Ping Services with special SAP handling
        */
    export interface ILegacyPingServices {
            /**
                * Send ping request to server.
                */
            pingServer(serverType?: string): Promise<boolean>;
            /**
                * Send ping request to service.
                */
            pingService(serverType?: string): Promise<boolean>;
    }
    /**
        * Supports legacy request timeout functions
        * These functions should not be used anymore, but are referenced in some framework version <5
        */
    export interface IInternalRequestTimeout {
            /**
                * Retrieves the current request timeout
                * @apilevel 3
                * @deprecated
                */
            getRequestTimeout(): Promise<number>;
            /**
                * Change the request timeout to the specified value.
                * @param timeoutInMilliseconds number of millisecons to wait until a timeout is thrown
                * @apilevel 3
                * @deprecated
                */
            setRequestTimeout(timeoutInMilliseconds: number): Promise<void>;
    }
    /**
        * Internal Request Timeout Management
        */
    export interface IInternalRequestTimeoutV2 {
            /**
                * Resets the request timeout to the platform default
                * @apilevel 3
                */
            resetRequestTimeout(): Promise<void>;
    }
    /**
        * Request Timeout Management
        */
    export interface IExternalRequestTimeout {
            /**
                * Retrieves the current request timeout
                * @apilevel 3
                */
            getTimeoutInMilliseconds(): Promise<number>;
            /**
                * Change the request timeout to the specified value.
                * @param timeoutInMilliseconds number of millisecons to wait until a timeout is thrown
                * @apilevel 3
                */
            setTimeoutInMilliseconds(timeoutMS: number): Promise<void>;
            /**
             * Resets the request timeout to the platform default
             * @apilevel 3
             */
            resetTimeoutToDefault(): Promise<void>;
    }
    /**
        * LEGACY SPECIAL HTTP Client
        * This client already executes SAP and Session error handling
        * Also it is only supported to send an request to the dataserver url
        * determined by https://<datahost>:<dataport>/<dataservice>(/<resourceUrl>?)
        */
    export interface ILegacyHTTPClient {
            /**
             * Send http request to backend using DELETE method.
             */
            del(resourceUrl: string, timeoutInMilliseconds?: number): Promise<LegacyResponse>;
            /**
                * Send http request to backend using GET method.
                */
            get(resourceUrl: string, params?: HttpParams, timeoutInMilliseconds?: number): Promise<LegacyResponse>;
            /**
                * Send http request to backend using POST method.
                */
            post(resourceUrl: string, data: object, timeoutInMilliseconds?: number): Promise<LegacyResponse>;
            /**
                * Send http request to backend using PUT method.
                */
            put(resourceUrl: string, data: object, timeoutInMilliseconds?: number): Promise<LegacyResponse>;
            /**
                * Download data for Offline DB from server.
                */
            downloadResource(resourceUrl: string, timeoutInSeconds?: number): Promise<LegacyResponse>;
            /**
                * Upload Offline data history to server.
                */
            uploadResourceLog(data: object, timeoutInMilliseconds?: number): Promise<LegacyResponse>;
    }
    /**
        * SPECIAL MSB HTTP Client
        * The SAP service handling is already included
        * Don't use this client if you want to send raw requests
        */
    export interface IMSBHTTPClient {
            /**
                * Download a binary file to a local url
                */
            downloadFile(sourceUrl: string, localFileUrl: string, timeoutInMilliseconds?: number): Promise<string>;
            /**
                * Send a request which ensures an msb data server session and does specific error handling.
                */
            sendMsbDataRequest(method: HTTPMethod, url: string, payload: any, headers: HTTPHeaders, timeoutInMilliseconds?: number): Promise<GenericResponse>;
            /**
                * Upload file to any destination (postBinary only supports fixed file service and should be considered "legacy")
                * @param targetUrl Url which receives the file
                * @param localFileUrl Location of the file to be sent
                * @param headers Additional headers
                */
            uploadFile(targetUrl: string, localFileUrl: string, headers: HTTPHeaders, timeoutInMilliseconds?: number): Promise<GenericResponse>;
    }
    /**
        * Public HTTP Client interface
        */
    export interface IHTTPClient extends Pick<IMSBHTTPClient, 'downloadFile' | 'uploadFile'>, IInternalRequestTimeout, IInternalRequestTimeoutV2, IRedirectHandling {
            /**
                * Send a simple http request. No special msb/sap/whatever handling.
                */
            sendRequest(method: HTTPMethod, url: string, payload: any, headers: HTTPHeaders, timeoutInMilliseconds?: number): Promise<GenericResponse>;
    }
    /**
        * Cookie Management
        */
    export interface ICookieUtil {
            /**
                * Clear internal cookie store.
                */
            clearCookies(): Promise<void>;
            /**
                * removes cookies for the given host url
                * @param url host
                */
            removeCookies(url: string): Promise<void>;
    }
    /**
        * Header Management
        */
    export interface IHeaderUtil {
            /**
                * Get all header from backend
                * @param host
                */
            getHeader(host: string): Promise<Record<string, string>>;
            /**
                * Set the header for a specific host name
                * @param host hostname
                * @param name header name
                * @param value header value
                */
            setHeader(host: string, name: string, value: string): Promise<void>;
    }
    /**
        * Certificate Management
        */
    export interface ICertUtil {
            /**
                * Resets the tls certificate to none
                */
            resetCert(): Promise<void>;
            /**
                * Set the tls certificate for outgoing connections
                * @param cert certificate as buffer
                * @param passphrase password to decrypt the certificate
                */
            setCert(cert: BufferSource, passphrase?: string): Promise<void>;
    }
    /**
        * Cache Service
        */
    export interface ICacheServices {
            /**
                * Synchronize cache.
                * Deletes expired, invalid and out of sync files from binary cache folder.
                */
            syncCache(): Promise<void>;
    }
    export interface IRedirectHandling {
            setFollowRedirects(enabled: boolean): Promise<void>;
    }
    export type IInternalCommunication = ILegacyHTTPClient & ILegacyPingServices & ILegacyFileTransfer & IInternalRequestTimeout & IInternalRequestTimeoutV2 & IMSBHTTPClient & IHTTPClient & ICacheServices & ICookieUtil & IRedirectHandling;
    export interface IExternalCommunication extends ILegacyHTTPClient, IMSBHTTPClient, Pick<IHTTPClient, 'sendRequest'>, Pick<ICookieUtil, 'clearCookies'>, ICacheServices, Partial<IInternalRequestTimeout>, Partial<IExternalRequestTimeout>, ILegacyFileTransfer, ILegacyPingServices, IRedirectHandling {
    }
    export default interface ICommunication extends IExternalCommunication {
    }
}

declare module 'core/interfaces/database' {
    import type { Dexie } from 'dexie';
    export interface CompoundSpec {
            parts: string[];
    }
    export interface KeySpec {
            name: string;
            autoIncrement: boolean;
            isBlank: boolean;
    }
    export interface IndexSpec {
            name: string;
            isUnique: boolean;
            isMultiValue: boolean;
            compound?: CompoundSpec;
    }
    export interface TableSchema {
            name: string;
            primaryKey: KeySpec | string[];
            indices: IndexSpec[];
    }
    export interface StoreSchema {
            name: string;
            tables: TableSchema[];
    }
    export interface DatabaseSchema {
            application: string;
            databases: StoreSchema[];
    }
    /**
        * Zero based range representation
        * @example { begin: 0, end: 20 } => [0 to 19]
        * @example { begin: 5, end: 79 } => entries [5 to 78]
        */
    export type Range = {
            /**
                * zero based offset
                */
            begin?: number;
            /**
                * zero based limit which is calculated like end - (begin || 0) => limit
                */
            end?: number;
    };
    export interface IDatabaseStore {
            /**
                * Adds an entry to the corresponding table
                * @param table table name
                * @param data entry to add
                */
            add(table: string, data: any): Promise<any>;
            /**
                * Execute multiple operations on several tables
                * @param tables affected tables
                * @param dbOperations array of operations
                */
            bulkExecute(tables: string[], dbOperations: any[]): Promise<void>;
            /**
                * Retrieves multiple items via paralel requests to db-core
                * WARNING: do not retrieve to many items at once
                * @param table
                * @param keys
                * @apilevel 3
                * @returns Promise of array of (entry | undefined), each non existing key is represented with the value undefined
                */
            bulkGet?(table: string, keys: any[]): Promise<any[]>;
            /**
                * Add or modify data in bulk
                * @param table
                * @param data array of entries to modify / add
                */
            bulkPut(table: string, data: any[]): Promise<any>;
            /**
                * Completly clear the table
                * @param table table name
                */
            clear(table: string): Promise<void>;
            /**
                * Count all entries of an table which matches a predicate
                * @param table table name
                * @param predicate optional predicate function
                * @apilevel 3
                */
            count?(table: string, predicate?: {
                    (obj: any): boolean;
            }): Promise<number>;
            /**
                * Delete an entry from the corresponding table
                * @param table table name
                * @param key primary key
                */
            delete(table: string, key: any): Promise<void>;
            /**
                * Filter the entries of an corresponding table
                * @param table table name
                * @param predicate filter function
                * @returns array of filtered entries
                */
            filter(table: string, predicate?: {
                    (obj: any): boolean;
            }): Promise<any[]>;
            /**
                * Retrieve a specific entry from the corresponding table
                * @param table table name
                * @param key primary key or equality criterias object
                */
            get(table: string, key: any): Promise<any>;
            /**
                * Replace or add an entry of the corresponding table
                * @param table table name
                * @param data entry to replace/add
                */
            put(table: string, data: any): Promise<any>;
            /**
                * Request and limit the entries of a table
                * @param table table name
                * @param range range object
                * @returns array of requested entries
                */
            toArray(table: string, range?: Range): Promise<any[]>;
            /**
                * Returns the raw dexie instance
                * @apilevel 3
                */
            getInstance?(): Dexie;
    }
    export default interface DatabaseModule {
            create(dbSchema: DatabaseSchema): Promise<void>;
            deleteDB(dbSchema: DatabaseSchema): Promise<void>;
            migrate(newSchema: StoreSchema, oldSchema: StoreSchema): Promise<void>;
            rebuild(dbSchema: DatabaseSchema): Promise<void>;
            openDatabases(guid: string): Promise<{
                    [databaseName: string]: IDatabaseStore;
            }>;
            executeUpload(uploadFunc: () => Promise<void>): Promise<void>;
            deleteRealDB(dbname: string): Promise<void>;
            getInstalledDatabases(): Promise<any>;
    }
    export type Store = IDatabaseStore;
}

declare module 'core/interfaces/debugging' {
    export default interface Debugging {
            /**
                * Delete all applications and frameworks that are currently installed.
                */
            deleteAllAppsAndFrameworks(): Promise<void>;
            /**
                * Run debug script located at "~/.fusionapp/debug.js".
                */
            runDebugScript(): void;
            /**
                * Restore factory defaults.
                * Warning all packages are deleted and all settings are wiped!
                */
            restoreFactoryDefaults(): Promise<void>;
    }
}

declare module 'core/interfaces/error' {
    import { FusionError } from 'core/error/error';
    export default interface ErrorModule {
        /**
          * Error class used for all types of errors reported to the API caller.
          *
          * @constructor
          * @param {string} [message = ""]
          * @param {string} [type = ""]
          * @param {number} [code = 0]
          * @param {object} [additional = null]
          * @return {FusionError}
          */
        FusionError: {
            new <T extends object>(message?: string, type?: string, code?: number, additional?: T): FusionError<T>;
        };
    }
}

declare module 'core/interfaces/filesystem' {
    import type { TARGETSTORAGE } from 'core/filesystem/path-helper';
    export interface Stats {
            mtime: Date;
            size?: number;
    }
    export type FileWatcherEvent = 'add' | 'change' | 'unlink';
    export type FileWatchHandler = {
            (eventType: FileWatcherEvent, filePath: string, lastModified: Date): void;
    };
    export interface IInternalFilesystem extends IFilesystem, IInternalFileWatcher {
    }
    export interface IExternalFilesystem extends IFilesystem, IFileWatcher {
            /**
                * Storagetype to choose from
                */
            TARGETSTORAGE: typeof TARGETSTORAGE;
    }
    export default interface FilesystemModule extends IExternalFilesystem {
    }
    export interface IFilesystem {
            copyFile(sourceFilePath: string, targetFilePath: string, overwriteIfExists: boolean): Promise<string>;
            /**
                * Create a directory.
                * @param dirName - directory name
                * @param continueOnExist - do not reject if directory already exists
                * @returns full path to the created directory
                */
            createDirectory(dirName: string, continueOnExist?: boolean): Promise<string>;
            /**
                * Delete a directory.
                */
            deleteDirectory(dirName: string, continueIfNotExist?: boolean): Promise<void>;
            /**
                * Delete a file.
                */
            deleteFile(filePath: string, continueIfNotExist?: boolean): Promise<void>;
            /**
                *
                * @param filePath relative file path
                */
            doesFileExist(filePath: string): Promise<boolean>;
            /**
                *
                * @param relativeOrAbsolutePath
                * @param storage
                */
            getAbsolutePath(relativeOrAbsolutePath: string, storage?: TARGETSTORAGE): Promise<string>;
            /**
                * Returns the stats of a file.
                */
            getFileStat(filePath: string): Promise<Stats>;
            /**
                * Read content of a directory.
                * @param dirPath path to directory
                * @returns An array listing all files/folders in given directory path.
                */
            readDirectory(dirPath: string, storage?: TARGETSTORAGE): Promise<string[]>;
            /**
                * Read content of a file in binary mode.
                * @param filePath path to file
                */
            readBinary(filePath: string): Promise<ArrayBuffer>;
            /**
                * Read content of a file.
                * @param filePath path to file
                * @param encoding nw.js only: handle special encoded text files (e.g. base64 images)
                */
            readFile(filePath: string, encoding?: string): Promise<string>;
            /**
                * Resolve the path of a selected camera image.
                */
            resolveCameraRollUri(imageName: string, doNotAdjustForWebview?: boolean): Promise<string>;
            /**
                * Resolve the path of a captured camera image.
                */
            resolveCameraUri(imageName: string, doNotAdjustForWebview?: boolean): Promise<string>;
            /**
                * Resolve file URI.
                */
            resolveFileUri(relativePath: string, doNotAdjustForWebview?: boolean): Promise<string>;
            /**
                * Resolve resource URI (files contained in "resources" folder of application package).
                * @param resourceName - name of resource
                * @param guid - GUID of application package
                * @param version - version of application package
                */
            resolveResourceUri(resourceName: string, guid: string, version: string, doNotAdjustForWebview?: boolean): Promise<string>;
            /**
                * Write data into a file.
                */
            writeFile(filePath: string, data: string | ArrayBuffer | Blob, encoding?: string, createPath?: boolean): Promise<void>;
    }
    export interface IInternalFileWatcher {
            /**
                * Removes a handler from a file to stop receiving notifications.
                */
            unwatchFile(filePath: string): void;
            /**
                * Attachs a handler to a file which receives notifications about changes.
                */
            watchFile(filePath: string): void;
    }
    export interface IFileWatcher {
            /**
                * Removes a handler from a file to stop receiving notifications.
                */
            unwatchFile(filePath: string, handler: FileWatchHandler): Promise<void>;
            /**
                * Attachs a handler to a file which receives notifications about changes.
                */
            watchFile(filePath: string, handler: FileWatchHandler): Promise<void>;
    }
}

declare module 'core/interfaces/geolocation' {
    /**
        * Partial of the html5 geolocation options
        */
    export type GeolocationOptions = {
            enableHighAccuracy: boolean;
            timeout: number;
            maximumAge: number;
    };
    export default interface IGeolocation {
            /**
                * Get current location
                * @param options accuracy and timeout options
                */
            getCurrentLocation(options?: Partial<GeolocationOptions>): Promise<GeolocationPosition>;
            /**
                * start watching for location changes
                * @param callback position callback to track location changes
                * @param options  geolocation options like accuracy and timeout
                */
            startGeoTracking(callback: GeolocationCallback, options?: Partial<GeolocationOptions>): Promise<number>;
            /**
                * stop watching for location changes
                * @param watchID watcher id (numeric)
                */
            stopGeoTracking(watchID: number): Promise<void>;
    }
    export type GeolocationCallback = (geolocation: GeolocationPosition) => any;
}

declare module 'core/interfaces/i18n' {
    export type LanguageBundle = {
            [key: string]: string | LanguageBundle;
    };
    export default interface ITranslationModule {
            /**
                * Translate a string if the key exists in the resource file.
                */
            t(key: string, options?: {
                    [key: string]: any;
            }): string;
            /**
                * Changes the current used language to another one
                * @param language language code to use (e.g. 'en' or 'de')
                */
            changeLanguage(language: string): Promise<any>;
            /**
                * Gets the currently used translation language
                */
            getCurrentLanguage(): string;
            /**
                * Gets the preferred translation language
                * (= the language selected in FIVE language settings, otherwise the fallback language "en")
                * @apilevel 3
                */
            getPreferredLanguage?(): Promise<string>;
            /**
                * Retrieves all installed translation languages
                */
            getLanguages(): string[];
            /**
                * Expand the current translation table with for a given language with a new set of translations
                * @param language 2 digit iso language code (e.g. 'en')
                * @param bundle object with key:value translation strings
                * @param override if set to true this will override existing translations, but do not remove existing ones.
                * @example
                * expandTranslations('en', { core: { translationXYZ: 'ABCD' } }, true);
                *
                * then
                *
                * t('core.translationXYZ');
                */
            expandTranslations(language: string, bundle: LanguageBundle, override?: boolean): void;
            /**
                * Expand the current translation table with for a given language with a new set of translations
                * @param language 2 digit iso language code (e.g. 'en')
                * @param namespace component namespace (e.g. default or 'framework')
                * @param bundle object with key:value translation strings
                * @param override if set to true this will override existing translations, but do not remove existing ones.
                * @example
                * expandTranslations('en', 'ComponentB', { core: { translationXYZ: 'ABCD' } }, true);
                *
                * then
                *
                * t('ComponentB:core.translationXYZ');
                */
            expandTranslations(language: string, namespace: string, bundle: LanguageBundle, override?: boolean): void;
    }
}

declare module 'core/interfaces/interop' {
    export default interface Interop {
            /**
                * Open a file in a new Window (node-webkit) or in another App (cordova).
                */
            openFile(filePath: string, mimeType?: string): Promise<void>;
            /**
                * Open another App via URL schemes.
                */
            openUrl(url: string): Promise<void>;
    }
}

declare module 'core/interfaces/logger' {
    export interface ILogLevel {
        value: number;
        name: string;
    }
    export default interface ILogger {
        debug(...args: any[]): void;
        info(...args: any[]): void;
        warn(...args: any[]): void;
        error(...args: any[]): void;
        log(...args: any[]): void;
        trace(...args: any[]): void;
        getLevel(): ILogLevel;
        setLevelByValue(value: number): void;
        getCurrentLogfileName?(): string;
        getLoglevels(): ILogLevel[];
        getLoglevelName(value: number): string;
        getLoglevelValue(name: string): number;
        getLogfilePath(): string;
        TRACE: ILogLevel;
        DEBUG: ILogLevel;
        INFO: ILogLevel;
        WARN: ILogLevel;
        ERROR: ILogLevel;
        OFF: ILogLevel;
    }
}

declare module 'core/interfaces/messaging' {
    import { FileWatcherEvent } from 'core/interfaces/filesystem';
    export type IMessagingPredefinedTopics = 'Invocation' | 'FileChange' | 'Message' | 'SetupProcess' | 'DisplayMessage' | 'Progress' | 'LanguageChange' | 'AppConfig' | 'PluginLoad' | 'PluginUnload' | 'ExternalCall';
    export interface IMessagingV1 {
        registerHandler(messageHandler: (type: string, message: any) => void): void;
        notifyHandler(type: string, message: string | Invocation): void;
        MessageType: MessageTypes;
    }
    export interface IMessagingV2 extends IMessagingV1 {
        subscribeToTopic(topic: 'Invocation', handler: {
            (invocation: Invocation): void;
        }): void;
        subscribeToTopic(topic: 'FileChange', handler: {
            (eventType: FileWatcherEvent, filePath: string, lastModified: number): void;
        }): void;
        subscribeToTopic(topic: 'Message', handler: {
            (type: MessageTypes, message: string | Invocation): void;
        }): void;
        subscribeToTopic(topic: 'SetupProcess', handler: {
            (options: {
                action: 'rebuildDatabase' | 'cancel';
            }): void;
        }): void;
        subscribeToTopic(topic: 'DisplayMessage', handler: {
            (options: {
                action: string;
                message: string;
            }): void;
        }): void;
        subscribeToTopic(topic: 'Progress', handler: {
            (eventType: 'show' | 'hide' | 'progress', data?: string): void;
        }): void;
        subscribeToTopic(topic: 'LanguageChange', handler: {
            (oldLanguage: string, newLanguage: string): any;
        }): void;
        subscribeToTopic(topic: 'AppConfig', handler: {
            (cmd: 'update' | string): void;
        }): void;
        subscribeToTopic(topic: 'PluginLoad', handler: {
            (id: string, pluginObject: any): any;
        }): void;
        subscribeToTopic(topic: 'PluginUnload', handler: {
            (id: string): any;
        }): void;
        subscribeToTopic(topic: 'ExternalCall', handler: {
            (callString: string): void;
        }): void;
        subscribeToTopic(topic: string, handler: HandlerFunction): void;
        unsubscribeFromTopic(topic: IMessagingPredefinedTopics | string, handler: HandlerFunction): void;
        notifyTopic(topic: 'Invocation', invocation: Invocation): void;
        notifyTopic(topic: 'FileChange', eventType: FileWatcherEvent, filePath: string, lastModified: number): void;
        notifyTopic(topic: 'Message', type: MessageTypes, message: string | Invocation): void;
        notifyTopic(topic: 'SetupProcess', options: {
            action: 'rebuildDatabase' | 'cancel';
        }): void;
        notifyTopic(topic: 'DisplayMessage', options: {
            action: string;
            message: string;
        }): void;
        notifyTopic(topic: 'Progress', eventType: 'show' | 'hide' | 'progress', data?: string): void;
        notifyTopic(topic: 'LanguageChange', oldLanguage: string, newLanguage: string): void;
        notifyTopic(topic: 'AppConfig', cmd: 'update' | string): void;
        notifyTopic(topic: string, ...message: any[]): void;
    }
    export type MessageHandler = (type: string, message: any) => void;
    export type HandlerFunction = {
        (...args: any): any;
    };
    export type Topic<MC> = {
        name: string;
        handler: MC;
    };
    export type MessageTypes = {
        ExternalInvocation: 'EXTERNAL_INVOCATION';
        DemoTimeout: 'DEMO_TIMEOUT_EXCEEDED';
        DemoMessage: 'DEMO_MESSAGE';
        InactivityTimeout: 'INACTIVITY_TIMEOUT_EXCEEDED';
    };
    export interface Invocation {
        input: string;
        host: string;
        version: number;
        guid: string;
        query: {
            [key: string]: string;
        };
    }
}

declare module 'core/interfaces/nfc' {
    /**
        * NFC Tag Data
        */
    export type NFCTagData = {
            tagId: string;
            techTypes: string[];
            type: string;
            maxSize: number;
            isWritable: boolean;
            canMakeReadOnly: boolean;
            ndefMessages: Partial<NFCTagDataNDEFMessage>[];
    };
    /**
        * NDEF Encapsulated Message
        */
    export type NFCTagDataNDEFMessage = {
            id: string;
            type: string;
            payload: string;
            tnf: string;
    };
    export default interface NFCModule {
            /**
                * Reads a single NFC (NDEF or supported binary) Tag
                * @returns NFC Tag Data
                */
            readTag(): Promise<Partial<NFCTagData>>;
            /**
                * Stops an existing nfc reader session
                */
            cancelReading(): Promise<void>;
    }
}

declare module 'core/interfaces/packages' {
    import { Invocation } from 'core/interfaces/messaging';
    export interface PackageReference {
            guid: string;
            version?: string;
    }
    export type PackageType = 'application' | 'framework' | 'plugin' | 'nwjs-app';
    export type PackageList = {
            [profileName: string]: {
                    [listKey: string]: PackageMetadata | undefined;
            } | undefined;
    };
    export interface PackageListItem extends Omit<PackageMetadata, 'version'> {
            /** list of available versions (meta-data of the packages) */
            versions?: PackageMetadata[];
            latestDependencies?: PackageMetadata[];
    }
    export interface ApplicationMetadata extends PackageMetadata {
            packageprocesstype?: 'full' | 'database';
            type: Extract<PackageType, 'application'>;
    }
    /**
     * Meta-data object holding additional package information.
     * Also holds information about which dependencies have an update available.
     */
    export interface PackageMetadata extends PackageReference {
            /** display name of package */
            name: string;
            type: PackageType;
            version: string;
            /** version marked as latest */
            latest?: string;
            linkedPackages?: PackageMetadata[];
            dependencies?: PackageReference[];
            isInstalled?: boolean;
            registerHandler?: string;
            needsprocessing?: boolean;
    }
    export type ApplicationList = {
            installed: PackageMetadata[];
            notInstalled: PackageMetadata[];
            orphaned: PackageMetadata[];
    };
    export default interface Packages {
            /**
                * Get the application selection bundle.
                */
            getAppSelectionBundle(): PackageReference;
            /**
                * Get the login bundle.
                */
            getLoginBundle(): PackageReference;
            /**
                * Clear all installed applications.
                */
            deleteApplicationsForProfile(profileName: string): Promise<void>;
            /**
                * Delete all databases for all installed applications of the current profile.
                */
            deleteDatabasesForProfile(profileName: string): Promise<void>;
            /**
                * Clear all caches and all installed applications.
                */
            deletePackagesForProfile(profileName: string, shouldDeleteDatabases?: boolean): Promise<void>;
            /**
                * Clear package cache.
                */
            clearCache(): Promise<void>;
            /**
                * Get reference of the start application.
                */
            getStartApplication(): PackageReference;
            /**
                * Get list of installed, available and orphaned applications.
                */
            getApplicationList(): Promise<ApplicationList>;
            /**
                * Gets the list of stored application from cache or creates the cache
                * @param listType Type to filter packages (0 - 3)
                * 1. 0 => NoFilter
                * 2. 1 => Applications
                * 3. 2 => Frameworks
                * 4. 3 => Plugins
                */
            loadCachedAvailablePackagesList(listType?: number): Promise<PackageListItem[]>;
            /**
                * Get list of the latest dependency versions for each of the specified applications.
                */
            getLatestDependenciesList(packageReferences: PackageReference[]): Promise<PackageListItem[]>;
            /**
                * Install a package.
                */
            install(packageReference: PackageReference, overrideSemVer: boolean, oldpackageReference?: PackageReference): Promise<void | PackageReference>;
            /**
                * Check if a package is installed
                */
            isInstalled(packageReference: PackageReference): boolean;
            /**
                * Set the start application used when the app is loaded. Default is the bundled wizard application.
                */
            setStartApplication(packageReference: PackageReference): void;
            /**
                * Start an application.
                */
            startApplication(packageReference: PackageReference): Promise<void>;
            /**
                * Try to start an application via autostart arguments or invocation args
                * @param invocation invocation args
                * @param internalStart bypass checks & install application if it isn't installed already
                */
            tryAutoStart(invocation?: Invocation, internalStart?: boolean): Promise<boolean>;
            /**
                * Uninstall an application and its non-referenced dependencis.
                */
            uninstall(packageReference: PackageReference): Promise<void>;
            /**
                * Updates an application or one of its dependencies.
                */
            update(packageReference: PackageReference, oldPackageReference: PackageReference, overrideSemVer: boolean): Promise<void | PackageReference>;
    }
}

declare module 'core/interfaces/plugins' {
    import type { IOptions } from '@mobisys-internal/cordova-plugin-barcode-scanner';
    export interface BarcodeOptions extends IOptions {
            /**
                * The percentage size of the viewfinder. Where 1 corresponds to 100%.
                */
            viewFinderSize?: number;
    }
    export type BarcodeScanParam = BarcodeOptions | boolean;
    export interface BarcodeResult {
            /**
                * The text representation of the barcode data.
                */
            text?: string;
            /**
                * The format of the barcode - e.g. QR_CODE, EAN_13, etc.
                */
            format?: string;
            /**
                * The type of the barcode - e.g. URL, PRODUCT, etc.
                */
            type?: string;
            /**
                * Indicates if the user cancelled the scan process.
                */
            cancelled: boolean;
    }
    export interface Barcode {
            scan(options?: BarcodeScanParam): Promise<BarcodeResult>;
    }
    export interface BarcodePluginOptions {
            detectorSize: {
                    width: number;
                    height: number;
            };
    }
    export interface FileInfo {
            path: string;
            name: string;
            mimeType: string;
    }
    export interface ExtendedFileInfo extends FileInfo {
            data: ArrayBuffer | Uint8Array;
    }
    export interface CDVFileInfo {
            mediaType: string;
            uri: string;
            dataURI: string;
            data: Uint8Array;
            name: string;
    }
    export type CameraFileInfo = Omit<FileInfo, 'name'>;
    export interface Camera {
            /**
                * Capture a picture with the front camera of the device.
                */
            captureImage(quality?: number, targetWidth?: number, targetHeight?: number): Promise<CameraFileInfo>;
            /**
                * Remove all images kept in temporary storage.
                */
            cleanup(): Promise<void>;
            /**
                * Choose an image from the device's photo library or camera roll album.
                * @param {boolean} useCameraRoll - Choose image from camera roll album instead of the photo library.
                */
            selectPicture(useCameraRoll: boolean): Promise<CameraFileInfo>;
            /**
                * Choose multiple images from the device's photo library or camera roll album.
                * @param {boolean} useCameraRoll - Choose image from camera roll album instead of the photo library.
                */
            selectPictures(useCameraRoll: boolean): Promise<CameraFileInfo[]>;
            /**
                * Choose a video from the device's video library.
                */
            selectVideo(): Promise<CameraFileInfo>;
            /**
                * Choose multiple videos from the device's video library.
                */
            selectVideos(): Promise<CameraFileInfo[]>;
    }
    export interface Keyboard {
            /**
                * Disable scrolling when the the WebView is shrunk.
                */
            disableScrollingInShrinkView(value: boolean): void;
            /**
                * Show the keyboard.
                */
            show(): void;
            /**
                * Hide the keyboard.
                */
            hide(): void;
            /**
                * Hide the keyboard toolbar.
                */
            hideFormAccessoryBar(value: boolean): void;
            /**
                * Shrink the WebView when the keyboard comes up.
                */
            shrinkView(value: boolean): void;
    }
    export interface FilePicker {
            /**
                * Let the user pick files from the filesystem
                *
                * @param commaSeparatedMimeTypes Comma-separated list of file mime types, e.g. "image/png,image/jpg". Empty string for any file.
                * @param allowMultiple If true, multiple selection is allowed
                */
            pickFile(commaSeparatedMimeTypes: string, allowMultiple: boolean): Promise<FileInfo[]>;
    }
    export interface MediaService {
            captureAudio(): Promise<string>;
            captureImage(quality: number): Promise<string>;
            captureVideo(): Promise<string>;
            selectImage(config?: {
                    maxItems?: number;
                    includeVideos?: boolean;
            }): Promise<string[]>;
    }
    export default interface Plugins {
            barcode: Barcode;
            camera: Camera;
            keyboard: Keyboard;
            filePicker: FilePicker;
            mediaService(): MediaService;
    }
}

declare module 'core/interfaces/session' {
    import type { Authentication } from 'core/authentication/authentication.class';
    import type { OSName } from 'core/interfaces/util';
    import type { SessionType } from 'core/session/session-types';
    export type { SessionType } from 'core/session/session-types';
    export type LoginFunction = {
            (sessionType: SessionType): Promise<void>;
    };
    export interface Role {
            roleid: string;
            roletext: string;
    }
    export interface SystemInfo {
            /**
                * Authentication Method
                */
            auth_meth: string;
            /**
                * SAP MSB5 Session Timeout
                */
            session_to: string;
            /**
                * SAP System Name
                */
            sys: string;
            /**
                * SAP System Identifier
                */
            sysid?: string;
            /**
                * User Roles
                */
            roles?: Role[];
    }
    export type AuthData = {
            /**
                * MSB5 Device ID
                */
            deviceid: string;
            /**
                * Device Name
                */
            devicename: string;
            /**
                * OEM Info
                */
            oeminfo: string;
            /**
                * OS Info -> Name
                */
            osinfo: OSName;
            /**
                * Timezone difference
                */
            tzd: string | number;
            /**
                * Core API - Version
                */
            version: string;
            /**
                * SAP Username
                */
            uname?: string;
            /**
                * Current SAP Password
                */
            pass?: string;
            /**
                * New password to set (do not set if you're not willing to change your current password)
                */
            npass?: string;
    };
    export interface ISessionHandler {
            /**
                * Register thte language change handler in the corresponding session
                * @param sessionType Session Type
                */
            registerLanguageChangeHandler(sessionType: SessionType): Promise<void>;
            /**
                * Login to SAP system
                * @param sessionType Data / Package session
                */
            login(sessionType: SessionType, auth: Authentication): Promise<void>;
            /**
                * Logout and dispose session.
                */
            logout(sessionType: SessionType): Promise<void>;
            /**
                * Requests SAP system infos
                * @param username Username
                * @param password Password
                * @param sessionType Data / Package session
                */
            requestSysInfo(sessionType: SessionType): Promise<SystemInfo>;
            /**
                * Request a licence and switch into licenced mode (disable demo mode).
                */
            switchToLicencedMode(session: Session): Promise<void>;
    }
    export interface Session {
            auth: {
                    type: string;
                    config: Record<string, any>;
            };
            inactivityTimeout: number;
            expiryTimestamp: any;
            user: string;
            systemType: string;
            authenticationMethod: number;
            creationTimestamp: number;
            isLicenced: boolean;
            isStateful: boolean;
            isExpired: boolean;
            isOffline: boolean;
    }
    export interface License {
            encrypted: string;
            licenceType: string;
            licenceNumber: string;
            sapInstallCode: string;
            expiryDate: string;
    }
    export interface IInternalSessionModule {
            /**
                * Check if a valid session exists.
                */
            checkSession(type: SessionType): Promise<void>;
            /**
                * Show if package and data server are divergent.
                */
            isDivergentDataServer(): boolean;
            /**
             * Login to backend and create a session.
             */
            startSession(type: SessionType, auth?: Authentication): Promise<Session>;
    }
    export type IInternalSession = SessionModule & IInternalSessionModule;
    export default interface SessionModule {
            /**
                * Get current session data.
                */
            getSession(type?: SessionType): Session | undefined;
            /**
                * Logout and dispose session.
                */
            logout(type: SessionType): Promise<void>;
            /**
                * Reset logout timer (must be called on user interaction)
                */
            resetLogoutTimer(): void;
            /**
                * Request a licence and switch into licenced mode (disable demo mode).
                */
            switchToLicencedMode(): Promise<void>;
            /**
                * Switch to a stateful session.
                */
            switchToStateful(): Promise<void>;
            /**
                * Switch to a stateless session.
                */
            switchToStateless(): Promise<void>;
            /**
                * Session Types
                */
            sessionTypes: typeof SessionType;
    }
}

declare module 'core/interfaces/sound' {
    export type PlaySoundOptions = {
            volume: number;
            delay: number;
            offset: number;
            duration: number;
            loopCount: number;
            loopDelay: number;
    };
    /**
        * Sound Module
        */
    export default interface ISoundModule {
            /**
                * Plays a sound from a path. Options can be supplied to control loop behavior, volume, etc.
                * @param filepath path to the file to read
                * @param options sound options
                * @returns unique index to stop the sound
                */
            playSound(filepath: string, options?: Partial<PlaySoundOptions>): Promise<number>;
            /**
                * Stops the playback of a sound buffer
                * @param filepath filepath of a specific sound file to stop all sound buffers
                * @param index unique index to stop a specific sound buffer of a specific sound file
                */
            stopSound(filepath?: string, index?: number): Promise<void>;
    }
}

declare module 'core/interfaces/settings' {
    import type { AppConfigResult } from 'core/interfaces/app-configuration';
    import type { DeviceSettings } from 'core/interfaces/profiles';
    import type { FIVEProfile } from 'core/settings/five-profile';
    export interface IProfile {
            /**
                * Retrieves the current used profile
                */
            getActiveProfile(): FIVEProfile;
            /**
                * Creates a new FIVE profile
                * @param profileName name of the profile
                */
            createProfile(profileName: string): FIVEProfile;
            /**
                * Write current changes to the configuration.
                * @param fiveProfile - the specific FIVE profile to save
                */
            saveProfile(fiveProfile: FIVEProfile): Promise<void>;
            /**
                * Delete the specified profile.
                * @param profileName - name of the profile to be deleted
                */
            deleteProfile(profileName: string): Promise<void>;
            /**
             * Get all profile names.
             * @param profileType - is set to restrict results to a specific profile type
             */
            getAllProfileNames(profileType?: 'development' | 'production'): string[];
            /**
                * Write specified profile to config and set it as active profile.
                * @param profileName - name of the profile to be loaded
                */
            loadProfile(profileName?: string): void;
            /**
                * Write specified profile to config and set it as active profile.
                * @param profileName - name of the profile to be loaded
                */
            loadProfileAsync(profileName?: string): Promise<void>;
    }
    export interface IProfileInternal {
            /**
                * Retrieves all stored profiles
                */
            getAllProfiles(): FIVEProfile[];
            /**
                * Retrieves a profile from stored profiles
                * @param name The profile name which you want to retrieve
                * @remarks this does not load the retrieve profile (activate)
                */
            getProfile(name: string): FIVEProfile | undefined;
    }
    export interface IDeviceSettings {
            /**
                * Retrieves the current device settings
                */
            getDeviceSettings(): DeviceSettings;
            /**
                * Saves the current device settings in encrypted form for further use.
                * @param settings actual settings object
                */
            saveDeviceSettings(settings: DeviceSettings): Promise<void>;
    }
    export interface IManagedSettings {
            /**
                * Get a managed value from the app configuration.
                */
            getManagedValue(): Promise<AppConfigResult | undefined>;
            /**
             * Get a managed value from the app configuration.
             * @param key field name to resolve the managed value from
             */
            getManagedValue(key: string): Promise<boolean | number | string | undefined>;
    }
    export interface IManagedSettingsInternal {
            /**
                * Set the managed config value for a specific key
                * @param key specific field identifier
                * @param value any value
                */
            setManagedValue(key: string, value: any): Promise<void>;
    }
    export type IInternalSettings = ISettings & IDeviceSettings & IProfile & IManagedSettings & IManagedSettingsInternal & IProfileInternal;
    export interface ISettings {
            /**
                * Get the name of the active profile.
                */
            getActiveProfileName(): string;
            /**
                * Get the profile key of the specified profile.
                * @param profileName - name of the profile
                * @deprecated 3
                */
            getProfileKey(profileName: string): string;
    }
}

declare module 'core/interfaces/util' {
    export type OSName = 'Mac OS' | 'Linux' | 'Windows' | 'Android' | 'amazon-fireos' | 'browser' | 'iOS' | 'unknown';
    /**
        * Data or Package Server
        */
    export type ServerType = {
            data: 'dataServer';
            pkg: 'pkgServer';
    };
    /**
        * Format: http(s)://<host:port>/<service>/<path?>/<resource?>
        */
    export type SapUrl = string;
    interface HelperDialogModule {
            /**
                * Displays a 'native' confirmation box
                * @param message message to show
                * @param {String} [title = 'Confirm'] title title of the confirmation box
                * @param {String[]} [ buttonLabels = ['OK', 'CANCEL']] buttonLabels buttons ['OK', 'CANCEL'] - this is only supported on android
                */
            confirm(message: string, title?: string, buttonLabels?: string[]): Promise<boolean>;
            /**
                * Displays a 'native' message box
                * @param {String} message message to show
                * @param {String} [title = 'Alert'] title of the message box
                * @param {String[]} buttonName buttons ['OK'] - this is only supported on android
                */
            alert(message: string, title?: string, buttonName?: string): Promise<void>;
    }
    interface Helper {
            /**
                * Dialog Helper Module
                */
            dialogs: HelperDialogModule;
            /**
                * returns the type of an object
                */
            getTypeOf(object: any): 'array' | 'boolean' | 'function' | 'null' | 'number' | 'object' | 'string' | 'undefined' | 'unknown';
            /**
                * JSON.parse wrapped in try/catch
                * @param object Object String
                */
            tryParse(object: string): any;
    }
    export interface DeviceID {
            getMobisysId(): string;
    }
    export interface IEnvironment {
            /**
                * Get build number.
                */
            getBuildNumber(): string;
            /**
                * Get revision.
                */
            getBuildRevision(): string;
            /**
                * Get build type.
                */
            getBuildType(): string;
            /**
                * Get bundle ID.
                */
            getBundleID(): string;
            /**
                * Get core version.
                */
            getCoreVersion(): string;
            /**
                * Get device name.
                */
            getDevicename(): string;
            /**
                * Get engine ID.
                */
            getEngineId(): string;
            /**
                * Get OEM info.
                */
            getOemInfo(): string;
            /**
                * Get operating system info.
                */
            getOsInfo(): OSName;
            /**
                * Get operating system language.
                */
            getOsLanguage(): string;
            /**
                * Get platform ID.
                */
            getPlatformId(): string;
            /**
                * Get Startup arguments.
                */
            getStartupArguments(): {
                    [key: string]: string | boolean;
            };
            /**
                * Get timezone offset.
                */
            getTimezoneOffset(): any;
            /**
                * Get UUID.
                */
            getUuid(): string;
            /**
                * Returns the current version of the app
                * @version >=2.2.0
                */
            getVersionString(): string;
            /**
                * Checks if the app is running in cordova environment (iOS and Android)
                */
            isCordova(): boolean;
            /**
                * Checks if the app is running in node environment (node.js and nwjs)
                */
            isNode(): boolean;
            /**
                * Checks if the app is running exclusively in nwjs
                */
            isNw(): boolean;
            /**
                * Check if app was built locally.
                */
            isLocalBuild(): boolean;
            /**
                * WINDOWS ONLY: Try to register app as deeplinking handler.
                */
            registerDeepLinkingHandler(): Promise<void>;
    }
    export interface MD5 {
            /**
                * Get MD5 hash of a given string.
                * @param str String to be hashed
                * @param key Keyed-Hash Message Authentication Code
                * @param raw set output encoding; true: raw, false: hex (default)
                */
            hash(str: string, key?: string, raw?: boolean): string;
    }
    export interface SHA1 {
            /**
                * Get SHA1 hash of a given string.
                */
            hash(str: string): string;
    }
    export type URLResolverServerTypeValue = ServerType[keyof ServerType];
    export interface UrlResolverV2 {
            getBaseUrl: {
                    (serverType: URLResolverServerTypeValue, includeService?: boolean): string;
            };
    }
    export interface UrlResolver extends Partial<UrlResolverV2> {
            ServerTypes: ServerType;
            /**
                * Get the URL of the specified resource in the SAP REST service.
                * @param resource - name of the resource. E.g: 'DEMOVENDOR'
                */
            resolveResourceUrl: {
                    (resource: string): SapUrl;
            };
            /**
                * Get the URL of a binary resource.
                * @param resource - default: ''
                */
            resolveBinaryResourceUrl: {
                    (resource?: string): SapUrl;
            };
            /**
                * Returns the URL for uploading the offline changelog to SAP
                */
            resolveLogResourceUrl: {
                    (): SapUrl;
            };
            /**
                * Get URL of the specified control. E.g: ('sysinfo') => 'http://sapsys29.mobisys.org/MOBISYS/msbfive/sysinfo'.
                * @param control - name of the control
                * @param serverType - specifies if the URL should point to package- or data-source
                */
            resolveControlUrl: {
                    (control: string, serverType: ServerType[keyof ServerType]): SapUrl;
            };
            /**
                * Get the URL of the package server.
                */
            resolvePkgServerUrl: {
                    (): SapUrl;
            };
            /**
                * Get the URL of the data server.
                */
            resolveDataServerUrl: {
                    (): SapUrl;
            };
            /**
                * Get the URL over which a complete resource can be downloaded.
                * @param resource - name of the resource e.g:'DEMOVENDOR'
                */
            resolveDownloadResouceUrl: {
                    (resource: string): SapUrl;
            };
            /**
                * Get URL for uploading changelog.
                */
            resolveUploadLogUrl: {
                    (): SapUrl;
            };
            /**
                * Get a URL over wich the token for uploading offline commits can be obtained.
                */
            resolveTokenUrl: {
                    (): SapUrl;
            };
            /**
                * Get URL for Committing SAP-Token.
                */
            resolveCommitUrl: {
                    (): SapUrl;
            };
            /**
                * Get the URL that points to the MSB license information.
                */
            resolveLicenseUrl: {
                    (): SapUrl;
            };
    }
    export default interface Util {
            deviceId: DeviceID;
            environment: IEnvironment;
            helper: Helper;
            md5: MD5;
            sha1: SHA1;
            urlResolver: UrlResolver;
    }
    export {};
}

declare module 'core/session/session-types' {
    /**
      * Session Types
      * @enum {DATA} - set's the session for data server
      * @enum {PKG} - set's the session for package server
      */
    export enum SessionType {
        DATA = "data_session",
        PKG = "pkg_session"
    }
}

declare module 'core/error/error' {
    /** @module core/error */
    import { FusionError } from 'core/error/fusion-error-class';
    import { InvalidParamsError, NotImplementedError, NoImplementationError, UnsupportedEngineError } from 'core/error/generic-error';
    export type NestedErrorType = Partial<{
            nested: Error | null;
    }>;
    export { 
    /**
        * Error class used for all types of errors reported to the API caller.
        *
        * @constructor
        * @param {string} [message = ""]
        * @param {string} [type = ""]
        * @param {number} [code = 0]
        * @param {object} [additional = null]
        * @return {FusionError}
        */
    FusionError, 
    /**
        * InvalidParamsError
        *
        * @constructor
        * @param {string} [message = "N/A"] - a message describing which parameter is invalid
        * @return {FusionError}
        */
    InvalidParamsError, 
    /**
        * NotImplementedError
        *
        * @constructor
        * @param {string} [fnName = "N/A"] - name of the function which is not implemented
        * @return {FusionError}
        */
    NotImplementedError, 
    /**
        * NotImplementedError
        *
        * @constructor
        * @param {string} [moduleName] - name of the module which is not implemented
        * @param {string} [platformName] - name of the target platform
        * @return {FusionError}
        */
    NoImplementationError, 
    /**
        * UnsupportedEngineError
        *
        * @constructor
        * @param {string} [namespace = "N/A"] - namespace in which the error occured
        * @param {string} [engine = "unknown"] - engine which is not supported
        * @return {FusionError}
        */
    UnsupportedEngineError };
}

declare module 'core/filesystem/path-helper' {
    export enum TARGETSTORAGE {
        PRIVATE = 0,
        PUBLIC = 1
    }
    export function splitPath(pathString: string): {
        path: string;
        filename: string;
    };
    export function joinPath(path: string, name: string): string;
}

declare module 'core/authentication/authentication.class' {
    import type { IAuthenticationInput, IAuthenticationOutput, RequestModuleFN } from 'core/authentication/authentication.interfaces';
    export abstract class Authentication {
            /**
                * authentication inputs (specify your inputs here)
                */
            readonly inputs: IAuthenticationInput[];
            /**
                * configuration data (from mdm or user profiles)
                */
            config: Record<string, any>;
            /**
                * authentication outouts (specify types here and use them to provide output info)
                */
            readonly outputs: IAuthenticationOutput[];
            /**
                * authentication type and versioning
                * used as unique identifier
                */
            static readonly type: string;
            /**
                * authentication title key for translation purposes
                * e.g. myCustomAuth.title
                */
            static readonly title: string;
            /**
                * Specifies if the authentication is ready to use or still work in progress
                */
            static readonly isExperimental: boolean;
            /**
                * Function to hook into the registration process of the authentication class
                * This hook could be used to register translations, other data necessary
                */
            static onRegister?: (requestModule: RequestModuleFN) => Promise<any>;
            /**
                * Unregisters an existing authentication
                */
            static onUnregister?: (requestModule: RequestModuleFN) => Promise<any>;
            /**
                * authentication hook: before authentication happens
                */
            preAuthenticate?: () => Promise<any>;
            /**
                * authentication hook: after authentication happened
                */
            postAuthenticate?: () => Promise<any>;
            /**
                * function to request an external module
                */
            requestModule: RequestModuleFN;
            /**
                * function to request data (maybe ui, cli or process)
                * the output values need to match the input specification of the authentication
                *
                * @param auth requesting authentication provider
                * @param configData user configuration object
                */
            requestData?: (auth: Authentication, configData?: Record<string, any>) => Promise<Record<string, any>>;
            /**
                * transforms specification data to data object
                * @param input raw output specification and values
                * @returns transformed output object
                */
            protected transform(input: IAuthenticationOutput[]): Promise<Record<string, any>>;
            /**
                * Validates the data against the input specification
                * @param input input object as real map (key => value)
                * @returns validation state
                */
            validate(input: Record<string, any>): Promise<boolean>;
            /**
                * helper to lookup an output specification of an authentication flow
                * @param name name or id of the out
                */
            protected tryGetOutput(name: string): IAuthenticationOutput | undefined;
            /**
                * helper to lookup an input specification of an authentication flow
                * @param name name or id of the input
                */
            protected tryGetInput(name: string): IAuthenticationInput | undefined;
            /**
                * initiates the authentication process of this provider.
                * this function usally calls the pre- and postAuthenticate hooks.
                * @param data provided data by previous authentications or other calls (inheritence)
                * @returns transformed output data
                */
            abstract authenticate(data?: Record<string, any>): Promise<Record<string, any>>;
            /**
                * Data cleanup (destroys all relevant data)
                */
            abstract cleanup(): Promise<any>;
            /**
                * Creates an instance of this class with the provided data or returns null if the data is invalid
                */
            static create?(configData?: Record<string, any>): Authentication | null;
    }
}

declare module 'core/interfaces/app-configuration' {
    export type AppConfigValue = boolean | number | string | string[];
    type BoolString = 'true' | 'false';
    type RemoveIndex<T> = {
        [K in keyof T as string extends K ? never : number extends K ? never : K]: T[K];
    };
    export interface AppConfigProfile {
        profileName: string;
        allowCredentials?: BoolString | boolean;
        enableBarcodeLogin?: BoolString | boolean;
        saveOfflineCredentials?: BoolString | boolean;
        corporateSecret?: string;
        ['pkgServer.user']?: string;
        ['pkgServer.password']?: string;
        ['pkgServer.ssl']?: boolean | BoolString;
        ['pkgServer.port']?: number | string;
        ['pkgServer.hostname']?: string;
        ['pkgServer.service']?: string;
        ['pkgServer.mandant']?: string;
        ['pkgServer.divergent']?: boolean | BoolString;
        ['pkgServer.testmode']?: boolean | BoolString;
        ['dataServer.user']?: string;
        ['dataServer.password']?: string;
        ['dataServer.ssl']?: boolean | BoolString;
        ['dataServer.port']?: number | string;
        ['dataServer.hostname']?: string;
        ['dataServer.service']?: string;
        ['dataServer.mandant']?: string;
        ['pkgServer.authType']?: string;
        ['dataServer.authType']?: string;
        /** JSON string */
        ['pkgServer.authConfig']?: string;
        /** JSON string */
        ['dataServer.authConfig']?: string;
        [key: string]: AppConfigValue | null | undefined;
    }
    export interface AppConfigResult {
        activeProfile?: string;
        hideSettings?: boolean;
        logLevel?: string;
        requestTimeout?: number;
        moduleTimeout?: number;
        startApplication?: string | string[];
        saveLocalUser?: boolean;
        saveLocalPassword?: boolean;
        /** mdm profile versioning */
        profilesVersion?: number;
        [key: string]: AppConfigValue | null | undefined;
    }
    export interface AppConfigProcessedResult extends RemoveIndex<AppConfigResult> {
        profileList: AppConfigProfile[];
    }
    export type AppConfigCallback = (result?: AppConfigProcessedResult) => Promise<any>;
    export {};
}

declare module 'core/interfaces/profiles' {
    export interface DeviceSettings {
        logLevel: number;
        moduleTimeout: number | null;
        requestTimeout: number | null;
        reloadFramework: boolean;
        activeProfile: string;
        saveLocalUser?: boolean;
        saveLocalPassword?: boolean;
        lastCamera: string;
        lastBarcodeCamera: string;
    }
    export interface UserSettings extends GlobalSettings {
        version: number;
    }
    export interface LegacyServerSettings {
        hostname: string;
        port: number;
        mandant: string;
        service: string;
        ssl: boolean;
        user: string;
        password: string;
    }
    export type ServerSettings = Omit<LegacyServerSettings, 'user' | 'password'> & {
        authentication: {
            type: string;
            config: Record<string, any>;
        };
    };
    export interface GlobalSettings {
        connection: ConnectionSettings;
        allowCredentials: boolean;
        isManaged: boolean;
        saveOfflineCredentials: boolean;
        useOfflineLogin: boolean;
        [attribName: string]: string | boolean | number | object | undefined | null;
    }
    export interface ConnectionSettings {
        packageServer: ServerSettings;
        dataServer: ServerSettings;
        divergentConfiguration: boolean;
        testMode: boolean;
    }
}

declare module 'core/settings/five-profile' {
    import type { UserSettings, ConnectionSettings } from 'core/interfaces/profiles';
    export const DEFAULT_PROFILE_NAME: "demo";
    export class FIVEProfile implements UserSettings {
        version: number;
        name: string;
        enableBarcodeLogin: boolean;
        corporateSecret: string | null | undefined;
        isManaged: boolean;
        connection: ConnectionSettings;
        allowCredentials: boolean;
        saveOfflineCredentials: boolean;
        useOfflineLogin: boolean;
        [attribName: string]: string | number | boolean | object | null | undefined;
        constructor(name?: string);
        serialize(): string;
        deserialize(data: string | object): void;
        static tryParse(data: string): FIVEProfile | undefined;
        ['toString'](): string;
        get [Symbol.toStringTag](): string;
        get key(): string;
    }
}

declare module 'core/error/fusion-error-class' {
    export class FusionError<T = object> extends Error {
        readonly message: string;
        readonly type: string;
        readonly code: number;
        readonly name = "FusionError";
        readonly stack = "no stack information available";
        constructor(message?: string, type?: string, code?: number, additional?: T | null);
        ['toString'](): string;
        get [Symbol.toStringTag](): string;
    }
}

declare module 'core/error/generic-error' {
    import { FusionError } from 'core/error/fusion-error-class';
    export class InvalidParamsError extends FusionError {
        constructor(message?: string);
    }
    export class NotImplementedError extends FusionError {
        constructor(fnName?: string);
    }
    export class NoImplementationError extends FusionError {
        constructor(moduleName: string, platformName: string);
    }
    export class UnsupportedEngineError extends FusionError {
        constructor(namespace?: string, engine?: string);
    }
}

declare module 'core/authentication/authentication.interfaces' {
    import type { Authentication } from 'core/authentication/authentication.class';
    import type { RemoveIndex } from 'core/interfaces/helper';
    import type { IFIVEPublicAPI as PublicAPI } from 'core/interfaces/public';
    export type IAuthenticationInput = IAuthenticationStringInput | IAuthenticationNumberInput | IAuthenticationListInput | IAuthenticationSelectInput | IAuthenticationObjectInput | IAuthenticationSecureInput | IAuthenticationBooleanInput;
    export interface IAuthenticationInputPartial {
            /**
                * the identifier of this input
                */
            name: string;
            /**
                * a brief description of this input value
                * this should be used for ui interaction
                */
            description?: string;
            /**
                * Requires the existence of input values (for validation)
                */
            required: boolean;
            /**
                * Requires the existence of input value (in settings)
                */
            settingsRequired?: boolean;
            /**
                * Specifies the existence of a configuration input, meaning the user should be able to input this info
                * on request
                */
            isUserInput: boolean;
            /**
                * Determines if the user should be presented with this setting in the presentation container on login UI.
                */
            onLoginScreen?: boolean;
    }
    export interface IAuthenticationInputWithIcon extends IAuthenticationInputPartial {
            icon?: string;
    }
    export interface IAuthenticationStringInput extends IAuthenticationInputWithIcon {
            type: 'string';
            regex?: string;
            defaultValue?: string;
    }
    export interface IAuthenticationSecureInput extends IAuthenticationInputWithIcon {
            type: 'secure';
    }
    export interface IAuthenticationNumberInput extends IAuthenticationInputWithIcon {
            type: 'number';
            defaultValue?: number;
            min?: number;
            max?: number;
            isFloat: boolean;
    }
    export interface IAuthenticationObjectInput extends IAuthenticationInputPartial {
            type: 'object';
    }
    export interface IAuthenticationListInput extends IAuthenticationInputPartial {
            type: 'list';
            values: string[];
    }
    export interface IAuthenticationSelectInput extends IAuthenticationInputPartial {
            type: 'select';
            values: string[];
    }
    export interface IAuthenticationBooleanInput extends IAuthenticationInputPartial {
            type: 'boolean';
    }
    export type IAuthenticationOutput = Omit<IAuthenticationInput, 'required' | 'isUserInput' | 'settingsRequired'> & {
            value: any;
    };
    export type RequestModuleFN = <N extends keyof PublicAPI, R = N extends keyof RemoveIndex<PublicAPI> ? RemoveIndex<PublicAPI>[N] : any>(name: N) => Promise<R>;
    export type AuthenticationDerived = {
            new (): Authentication;
    } & typeof Authentication;
}

declare module 'core/interfaces/helper' {
    export type RemoveIndex<T> = {
        [K in keyof T as string extends K ? never : number extends K ? never : K]: T[K];
    };
}

declare module 'core/interfaces/public' {
    import type { IHeaderUtil, IExternalCommunication, ICertUtil } from 'core/interfaces/communication';
    import type { ICookieStorage } from 'core/interfaces/cookies';
    import type I18n from 'core/interfaces/i18n';
    import type Logger from 'core/interfaces/logger';
    import type { IInAppBrowser } from 'core/interfaces/in-app-browser';
    import type Interop from 'core/interfaces/interop';
    import type { IMessagingV2 } from 'core/interfaces/messaging';
    import type { IProfile } from 'core/interfaces/settings';
    import type { IAsyncStorage } from 'core/interfaces/storage';
    import type Util from 'core/interfaces/util';
    import type INFCModule from 'core/interfaces/nfc';
    import type ErrorModule from 'core/interfaces/error';
    import type { IFIVEAuthenticationCommon } from 'core/interfaces/authentication';
    import type { Authentication } from 'core/authentication/authentication.module';
    import type * as ILegacyPlugins from 'core/interfaces/plugins';
    export type IFIVEPublicAPI = {
        barcodes: ILegacyPlugins.Barcode;
        certificates: ICertUtil;
        common: IFIVEAuthenticationCommon;
        cookies: ICookieStorage;
        error: ErrorModule['FusionError'];
        headers: IHeaderUtil;
        http: IExternalCommunication;
        i18n: I18n;
        inappbrowser: IInAppBrowser;
        interop: Interop;
        logger: Logger;
        messaging: IMessagingV2;
        nfc: INFCModule;
        profiles: Pick<IProfile, 'getActiveProfile'>;
        secureStorage: IAsyncStorage;
        storage: IAsyncStorage;
        util: Util;
    } & Record<string, any>;
    export type IPublicSelf = {
        Authentication: Authentication;
    };
}

declare module 'core/interfaces/cookies' {
    export interface ICookieStorage {
        clearCookies(): Promise<void>;
        removeCookies(url: string): Promise<void>;
        getCookies(url: string): Promise<string>;
        setCookie(url: string, cookie: string): Promise<void>;
    }
}

declare module 'core/interfaces/in-app-browser' {
    import type { InAppBrowser } from '@mobisys-internal/cordova-plugin-inappbrowser';
    export interface IInAppBrowser {
            /**
                * opens an inappbrowser or routes the existing instance to the specified url
                * @param url target url to open
                */
            open(url: string, target?: string, options?: string): Promise<InAppBrowser>;
            /**
                * get cookies for a specific url from the current instance of the inappbrowser
                * (this is not the same as the cookies from communication/http module)
                * @param url target location and path as url
                * @returns All cookies as string in format "name=value;name2=value2;"
                */
            getCookieString(url: string): Promise<string | null>;
            /**
                * clear cookies
                */
            clearCookies(): Promise<void>;
    }
}

declare module 'core/interfaces/storage' {
    export interface IAsyncStorage {
        isSync: false;
        get: (key: string) => Promise<string | null>;
        set: (key: string, value: any) => Promise<void>;
        has: (key: string) => Promise<boolean>;
        remove: (key: string) => Promise<void>;
        clear: () => Promise<void>;
    }
    export interface ISyncStorage {
        isSync: true;
        get: (key: string) => string | null;
        set: (key: string, value: any) => void;
        has: (key: string) => boolean;
        remove: (key: string) => void;
        clear: () => void;
    }
    export interface IFileStorage extends IAsyncStorage {
        getBinary: (key: string) => Promise<ArrayBuffer | null>;
    }
}

declare module 'core/interfaces/authentication' {
    import type { Authentication } from 'core/authentication/authentication.module';
    import type { GenericResponse } from 'core/interfaces/communication';
    import type { AuthData } from 'core/interfaces/session';
    export interface IFIVEAuthenticationCommon {
            /**
                * Validates existing data and requests missing data with `requestData()`
                * @param auth authentication to validate and request data for
                */
            validateAndRequest(auth: Authentication): Promise<Record<string, any>>;
            /**
                * Generate Authentication Object to send with `sendDeviceLoginRequestToService()`
                * @param auth authentication to generate data for
                */
            generateAuthData(auth: Authentication, includeUserPass?: boolean): Promise<AuthData>;
            /**
                *
                * @param auth authentication to generate header data for
                */
            getGeneralHeader(auth: Authentication): Promise<Record<string, string>>;
            /**
                *
                * @param auth
                * @param authData
                * @param header
                */
            sendDeviceLoginRequestToService(auth: Authentication, authData: AuthData, header: Record<string, string>): Promise<GenericResponse>;
    }
}

declare module 'core/authentication/authentication.module' {
    export * from 'core/authentication/authentication.class';
    export * as AuthenticationBuilder from 'core/authentication/five/authentication.builder';
}

declare module 'core/authentication/five/authentication.builder' {
    import type { Authentication } from 'core/authentication/authentication.class';
    import type { AuthenticationDerived } from 'core/authentication/authentication.interfaces';
    import type { RemoveIndex } from 'core/interfaces/helper';
    import type { ServerSettings } from 'core/interfaces/profiles';
    import type { IFIVEPublicAPI } from 'core/interfaces/public';
    export function addAuthenticationType(auth: AuthenticationDerived): Promise<void>;
    export function removeAuthenticationType(auth: AuthenticationDerived): Promise<void>;
    export function addToModulePool<N extends keyof RemoveIndex<IFIVEPublicAPI>>(name: N, module: RemoveIndex<IFIVEPublicAPI>[N]): void;
    export function addToModulePool<N extends string>(name: N, module: any): void;
    export function fromServerSettings(data: ServerSettings): Authentication;
    export function fromConfiguration(type: string, data: object): Authentication;
    export function getSupportedTypes(): string[];
    export function getExperimentalTypes(): string[];
    export function registerRequestDataFN(requestDataFunc: Authentication['requestData']): void;
}

